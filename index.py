
# МД-моделирование  Леннард-Джонсовой  жидкости

# Программа получена путем прямого перевода с Фортрана на Питон
# программы, приведенной и подробно прокомментированной в учебном пособии
# Холмуродов Х.Т. МД-моделирование в химических исследованиях
# http://lrb.jinr.ru/new/news/book3.pdf

# Для ускорения работы цикл вычисления сил, действующих на частицу,
# переписан с использованием возможностей пакета numpy

# Экзаменационная программа должна подключить модуль vpython
# для визуализации начального и конечного положения частиц

import time
import numpy as np
import json

# Дамп для сохранения информации о каждом шаге моделирования.
# По сравнению с оригинальной программой удален блок "красивого" вывода информации в этот файл
fileToWrite = open('result2.txt', mode='w')
data = open('data.txt', mode='w')
    

#  число атомов в системе (можно поменять на 2048, чтобы оценить проблемы с быстродействием)
natom = 256

# Раздел выделения памяти под основные массивы данных (без заполнения самими данными)
# Все эти массивы представляют собой списки трехмерных векторов, т.е. матрицы  размера natom x 3

# массив радиус-векторов частиц
x_ = np.empty(natom*3).reshape(natom, 3)

# массив скоростей частиц здесь не задается, будет инициализирован значениями в нужном месте программы

# массив ускорений
a_ = np.empty(natom*3).reshape(natom, 3)

# массив векторов сил, действующих на каждую частицу (инициализируется нулями)
f_ = np.zeros(natom*3).reshape(natom, 3)

# входные безразмерные параметры:
# плотность, температура и шаг интегрирования системы по времени
densty = 0.9
temp = 1.5
step = 0.001

# квадрат шага по времени и половина этой величины
# (используются при численном интегрировании)
stepsq = step*step
stepsqh = 0.5*stepsq

# расчет координат атомов основан на схеме их расположения
# в узлах гранецентрированной решетки
# (в экзаменационном задании схема расположения более простая! Плотность задавать не нужно!)

# Объем вычисляется на основе инфоромации о плотности и количестве атомов
vol = natom/densty
# длина ребра куба - основной ячейки моделирования
cube = vol**(1/3)
cubeh = 0.5*cube

# расчеты количества повторений блока решетки в пространстве для заполнения
# объема моделирования

# Код формально переведен с Фортрана.
# Формат гранецентрированной решетки не допускает использование произвольного количества атомов:
# их число только такое, которое может быть размещено в кубе. 256 и 2048 - подходят.
# В экзаменационном задании эти расчеты не нужны!
nunit = (natom/4.)**(1/3)+0.1
ncheck = 4*(nunit**3)
while ncheck < natom:
    nunit += 1
    ncheck = 4*(nunit**3)
dist = 0.5*cube/nunit
x_[0] = np.array([0.0, 0.0, 0.0])
x_[1] = np.array([0.0, dist, dist])
x_[2] = np.array([dist, 0.0, dist])
x_[3] = np.array([dist, dist, 0.0])


# Задание начальных положений атомов
# В экзаменационной работе должна быть другая схема, в соответствии с вариантом А или Б
m = 0
kct = 0
for i in range(int(nunit)):
    for j in range(int(nunit)):
        for k in range(int(nunit)):
            for ij in range(4):
                if kct < natom:
                    x_[ij+m] = x_[ij]+2.0*dist * \
                        np.array([k, j, i], dtype=np.float64)
                    kct += 1
            m += 4

# Начальные скорости и их нормировка к начальной температуре

# равномерно распределенные случайные значения компонент скоростей частиц
v_ = np.random.uniform(-1, 1, (natom, 3))

# нормировка амплитуд скоростей, чтобы кинетическая энергия соотвествовала начальной температуре
velsq = np.sum(v_**2)
aheat = 3.e0*natom*stepsq*temp
factor = np.sqrt(aheat/velsq)
v_ *= factor

# количество шагов по времени
maxeq = 501
# итоговое время (step * maxeq) при переходе к размерным параметрам должно быть не меньше 1 пс
# в данном варианте - меньше!
# для подсчетов энергии
# в данном варианте программе не используется
energy = 0


start_time = time.time()
for ktime in range(maxeq):
    for i in range(natom-1):
        xij = x_[i] - x_[i+1:]
        xij[xij < -cubeh] += cube
        xij[xij > cubeh] -= cube
        rsq = np.sum(xij*xij, axis=1)
        rsqinv = 1.0/rsq
        r6inv = rsqinv*rsqinv*rsqinv
# формулу для вычисления потенциальной энергии необходимо скорректировать
# с учетом того, что r6inv в данной реализации - это вектор, а не скаляр, как было в Фортране
#        enr=4.0*r6inv*(r6inv-1.0)
        force_ = np.einsum('ki,k->ki', xij, rsqinv*48*r6inv*(r6inv-0.5))

        f_[i] += np.sum(force_, axis=0)
        f_[i+1:] -= force_
#        energy=energy+enr

# вычисление (безразмерных) ускорений атомов системы
    a_ = f_*stepsqh
# вычисление скоростей атомов
    v_ += 2.0*a_
# новые положения частиц
    x_ += v_+a_
    x_[x_ < 0] += cube
    x_[x_ > cube] -= cube
    
    for xx in x_: print(xx[0], xx[1], xx[2], file=data)
    print('', file=data)

# один раз за 5 (kstep) шагов результаты о координатах частиц выводятся в файл,
# и информация о номере шага выводится на экран
# для ускорения расчетов экзаменационного задания вывод в файл можно закомментировать
    kstep = 5
    if ktime % kstep == 0:
        print('time=', ktime, '\nx:', x_, file=fileToWrite)
        print('time = ', ktime, '/', maxeq-1, sep='')
# Обнуляем массив сил
    f_[:, :] = 0
# конец цикла по времени
delta_t = time.time() - start_time
print('dynamics successfully ended in', delta_t, 'seconds')
print('dynamics successfully ended in', delta_t, 'seconds', file=fileToWrite)
fileToWrite.close()

data.close()
